d(req,res){
	  for(var j =0;j<9000;j++){ j+=2; };
	  if( i <10 ){
		  
		  setTimeout(function(){  console.log('wobuxiangdanggefeiren!kewoweishenmezongshitibuqijing!')  },1000/60);
	  }
	  i++;
	  res.end(''+i);
  }
  
  
  以上面代码来讲，来一百并发控制台还是只打印10条console.log的数据（100并发等于上面100个方法），说明js必须一步一步执行的（如i++;for循环）并发也是要一步一步执行的，一个方法接一个方法的执行（没有同时），只有那些异步（延时
  ，数据库连接是延时的话）并发就不会等待，会处理下一步，然后延时那些谁快就执行谁先
  
  上面情况是只有一个进程服务器的情况下，多进程时可以开多个子服务器（并且用的是同一个端口），而多并发来时，客户端发送ip+端口请求，而ip对应服务器电脑，
  服务器电脑在根据它请求的端口来查找本地有没有这个端口，而只有一个对应端口的进程时就等于该进程注册很多个方法，js执行又是从上到下，所以下面的需要等待，形成
  阻塞。而有多个时，主进程会调用子进程来执行该请求，并把当前请求设为忙碌，而下次请求来时，主进程会找优先找没有忙碌的子进程来处理。虽然主进程处理子进程也是
  顺序的，但处理很快。虽然只一个进程时处理更快，但很多并发时需要等上个执行完，而多个时，是来回切换执行不等待（因为进程是切换执行的），多核服务器是多有处理器，是
  
